# アーキテクチャ

## 1. システム概要

このアプリケーションは、Next.jsを使用して構築されたTODOリスト管理システムです。  
ユーザーはタスクの作成、読み取り、更新、削除を行うことができます。

## 2. 技術スタック
- フロントエンド・バックエンド: Next.js 14.x
- 言語: TypeScript
- スタイリング: Tailwind CSS
- 状態管理: Jotai
- API: Next.js API Routes (※モック用)
- テスト: Vitest, React Testing Library
- UI開発環境: Storybook
- Linter/Formatter: Biome
- モックサービス: MSW (Mock Service Worker)


## 3. プロジェクト構造
```
src/
├── app/                  # Next.js App Router ページ
│   ├── api/              # API Routes
│   ├── completed/        # 完了済みタスクページ(※未実装)
│   └── page.tsx          # メインページ
├── components/           # 再利用可能なコンポーネント
│   ├── AddButton/        # タスク追加ボタン
│   ├── ErrorMessage/     # エラーメッセージ表示用コンポーネント
│   ├── Navigation/       # ナビゲーションコンポーネント
│   ├── TaskCard/         # タスクカードを構成する関連コンポーネント
│   ├── TaskList/         # タスクリスト
│   └── ui/               # 汎用UIコンポーネント。モデルに関心を持たないもの。
├── icons/                # SVGアイコンコンポーネント
├── libs/                 # 外部ライブラリに依存するwrapperやutilを置くディレクトリ
├── mocks/                # MSW等のmock用ディレクトリ
├── services/             # API呼び出し関数
└── types/                # TypeScript型定義
```

## 4. フロントエンド
- `app/`: Next.jsのルールに則ってAppRouterとして動きます。
  しかし、RSCはそれまでの歴史とは一線を画す仕組みゆえテストが難しく、今回はほとんど活用していません。
- `components/`: 各コンポーネントは「何に関心を持つか」で分けています。  
  Atomic Designは実際に運用するには互いに共通認識を育む必要があるため採用していません。  
  「関心事は何か」をベースにコンポーネントを切り分けて作成してください。
- `components/ui`: 特に`ui/`に配置したものは特に関心を持たない、見た目に徹しているものを配置しています。

### 4.1 各コンポーネント内のファイル構成

- `Example.tsx`: 実ファイル
- `Example.test.tsx`: テストファイル
- `Example.hooks.tsx`: HooksやExample内でのみ使用する処理をまとめたファイル
- `Example.stories.tsx`: Storybook用ファイル
- `index.ts`: export用ファイル

## 5. バックエンド

バックエンドは未実装のためmock代わりにNext.jsのRoute Handlerを使用しています。  
バックエンドがNext.js以外の場合にどのような対応を取るかはtodos.mdを参考にしてください。

## 6. 採用の経緯

### Next.js

2024年現在のフロントエンドの主流派。  
React19以降で本格的に採用される予定のReact Server Componentを組み込んでおり、従来のSingle Page Application（SPA）モデルではクライアントサイドでのレンダリングが主体となり、初期ロード時間の長さやSEOの課題がありました。  
一方、RSCを活用したNext.jsでは、サーバーサイドでのレンダリングとクライアントサイドの動的な挙動を必要に応じて選択可能です。

初期ページロードの高速化、SEOの改善、そしてバンドルサイズの削減を実現できます。  
また、RSCはデータフェッチをサーバーサイドで行うことでクライアントへの機密情報の露出を防ぎ、セキュリティが期待できます。  

ただし、サーバーサイドとクライアントサイドを常に意識しながら開発する必要があり、また、エコシステムもまだ発展途上であることは留意する必要があります。


### Jotai

タスクリストの管理のためにGlobal Stateを管理する必要がありました。  
ReactにはContext/Providerという組み込みの仕組みがありますが、このまま使うのは限定的な場面に限り、通常はライブラリに頼ります。  

RecoilというFacebookで開発されていたOSSがの経験があったのですが、事情により開発がストップしています。  
開発スピード確保のため、思想がこれと似ているとされるJotaiを採用しました。


### Vitest

Vitestはこれからの主流派になっていくテストスイートです。  
従来のテストフレームワークであるJestと比較して、Vitestは大幅に高速な実行速度が魅力です。  
VitestはネイティブのESMサポートによりトランスパイルのオーバーヘッドを最小限に抑えています。  

また、JestとのAPI互換性を持っており、Jestの知見を流用できます。  

新規にプロジェクトを採用する際にはJestでないと出来ないことがない限りは、Vitestを採用してよいと考えたため、こちらを採用しています。

### Storybook

数年間、バージョンが6.xで止まっていましたが、ここ1年ほどで一気に加速し8.x系まで開発が進んでいます。  
Storybookの更新が滞っていた間にも対抗になりそうなOSSは頭角を現さず、現在も首位を守り続けている印象です。  
以前までよく言われていた複雑さや起動の重さは改善され、十分楽に運用できるようになっているため、採用しました。

### Biome

元々はRomeというプロダクトでしたが、forkされてBiomeとなりました。  
ESLint + Prettierでも良かったのですが、単純に興味があったため採用しました。  
開発体験の向上が主な目的なので、プロダクトへの影響はありません。

